상속을 하는 이유: 객체지향은 재사용을 중시하기 때문에 코드의 재사용을 위해 상속이라는 기능을 이용한다. 초기에 공통적인 기능을 구현한뒤 후에 다른 코드에 기능을 추가하는 방식을 사용한다. 

C++에서의 상속은 클래스 사이에서 정의가능한데(객체끼리는 불가), 상속해주는 클래스를 기본 클래스 즉 부모클래스라 하며, 상속받는 클래스를 파생 클래스 즉 자식 클래스라 칭한다. 

상속의 목적 및 장점: 뼈대(기본클래스)를 초기에 단단하게 설계하면 살(파생클래스)을 쉽게 붙이고 간결하게 작성할수 있다. 또한 클래스의 구조적인 관계를 파악하는데 용이하며, 재사용과 확장을 통한 소프트웨어 생산성 확장에 도움이 된다.

간결화 사례 
class person의 경우 초기의 부모 클래스 이며 researcher와 student는 person의 자식, professor와 studentworker는 researcher와 student의 자식이다. 따라서 profe와 stuwor에게 person은 할아버지라고 볼수 있다. 

예제 8-1 
main 함수 내에서 Point p 는 기본 클래스의 객체를 생성한것 ColorPoint cp 는 파생클래스의 객체를 생성한것이다. cp.set은 기본클래스의 멤버를 호출한것이고, cp.setColor는 파생된 클래스를 호출한것이다. 마지막으로 showColorPoint는 파생 클래스의 멤버를 호출한것이다. 

업 캐스팅
파생 클래스 포인터가 기본 클래스 포인터에 치환되는것

다운 캐스팅 
기본 클래스의 포인터가 파생 클래스의 포인터에 치환되는 것

포인터를 사용해야 하는 이유

객체지향 프로그래밍이라는 교과 과정을 배우면서 항상 포인터를 사용하는 이유에 대해 고민하였습니다. 저희조는 지금까지 학교 생활을 하면서 여러 게임 제작과 같은 개발을 해왔는데 포인터를 사용하는 경우가 거의 없었습니다. 그래서 저희는 포인터를 어떤 경우에서 사용하는지 생각해보았습니다. 포인터는 메모리 주소를 직접 참조하므로 다양한 자료형 변수에 대한 접근 및 조작이 용이하고 메모리의 동적 할당을 가능하게 하며, 배열, 구조체 등 복잡하고 다양한 자료구조의 데이터에 쉽게 접근하고 조작할 수 있으며 이외에도 여러 상황에 사용함을 알게되었습니다. 결론적으로 사용 범위를 벗어난 경우에도 데이터를 공유할 수 있는 장점 덕분에 포인터를 이용한다는 것 입니다. 하지만 단점도 있었는데, 포인터 변수는 주소를 직접적으로 컨트롤하기 때문에 예외 처리가 확실하지 않을 경우 예상치 못한 문제가 많이 발생하고 선언만 하고 초기화를 하지 않을 경우 쓰레기 주소를 가리키고 있기 때문에 사용에 주의해야 하고, 포인터 변수는 주소를 직접 참조하기 때문에 의도하지 않게 원본값을 수정 할 수있다는 점이 있습니다. 그리고 포인터를 제대로 학습하지 않으면 오류를 범하기가 쉽고 기교적인 프로그램이 되기 쉽기 때문입니다. 확실한 장점이 있지만 이러한 단점들 때문에 저희는 그동안 포인터 사용을 기피하고 있었습니다. 즉, 그동안 포인터를 주의 깊게 공부하지 않고 무분별하게 사용하여 프로그램이 망가지는 것 보단 아에 사용하지 않고 프로그램을 구성하는것이 더 좋을것이라 판단했었습니다. 하지만 지금까지 포인터에 대해 공부하면서 메모리 사용의 중요성, 자료구조에 어떻게 적용될수 있는지에 대해 생각을 해보았고, 제대로 배워서 이전보다 더 효율적인 프로그램을 코딩하는것을 목표로 정하게 되었습니다. 

접근 지정자
protected 멤버 선언된 클래스에서 접근가능하고, 파생 클래스에서만 접근 허용된다. 

예제 8-2 
5,6번은 파생 클래스인데도 불구하고 왜 안될까?
상속은 클래스에만 가능하고 객체는 상속이 안되니, 오류가 나오게 된다. 

상속의 생성자 소멸자는 파생 클래스가 먼저 소멸된후, 기본 클래스의 소멸자가 나중에 실행되게 된다.

상속의 종류
상속 선언시 public, private, protected의 3가지 중 하나를 지정한다. 

예제 8-4 
1번 private이기 때문에 접근할수없음
2번 private로 바뀌기 때문에 접근 불가
3번 private로 바뀌기 때문에 접근 불가
4번 private이기 때문에 접근할수없음
5번 객체를 상속하려 하기때문에 접근불가
6번 Derived안에 있는 public 함수이기 때문에 컴파일 오류가 나오지 않음

예제 8-5
1번 객체이기 때문에 상속이 되지않고 접근 불가함
2번 객체이기 때문에 상속이 되지않고 접근 불가함
3번 protected로 바뀌기 때문에 접근이 불가하다. 
4번 private이기 때문에 접근 불가
5번 객체이기 때문에 상속이 되지않고 접근 불가함
6번 Derived안에 있는 public 함수이기 때문에 컴파일 오류가 나오지 않음

예제 8-6 
1번 2번은 base의 상속이기때문에 가능하지만 3번 4번은 derived를 상속 받기 때문에 불가하고 setB(x)만 실행되게 된다. 

다중 상속
상속받고자 하는 기본 클래스를 나열하고 이전에 상속하는것처럼 하면 된다. 하지만 이렇게 되면 기본 클래스 멤버의 중복 상속이라는 문제점이 발생하는데, 이를 해결하기위해 가상 상속이라는 방법을 사용한다. 가상상속은 파생클래스의 선언문에서 기본 클래스 앞에 virtual로 선언하면 다중 상속의 모호성을 해결할수있다.